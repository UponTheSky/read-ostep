# Interlude: Process API
- **crux**: what interfaces should the OS present for process creation & control?
- functionality, ease of use, high performance

## 1. The `fork` System Call
- for creating a new process
- the process created is an almost exact copy of the calling process
  - the child doesn't start running from the beginning
  - rather, it just comes into life as if it had called `fork` itself
  - the return value of `fork` is `0` for the child, whereas the parent gets
  the pid of the child

- right after `fork` returns, the output is non-deterministic
  - the CPU scheduler determines which process runs at a given moment in time
  - **concurrency**, **multi-threaded programs**

## 2. The `wait` System Call
- for a parent to wait for a child process to finish what it has been doing
- when the child is done, `wait` returns to the parent
- adding a `wait` call to the code above make the output deterministic

## 3. Finally, The `exec` System Call
- for running a program that is different from the calling program
- how does it work?
  - given the name of an executable and some arguments, `exec` loads code and static data from that executable
  - then it overwrites its current code segment and current static data with it
    - the heap and stack and other parts of the memory space of the program are re-initialized
  - then the OS simply runs the program, passing in any arguments

- so `exec` doesn't create a new process but rather transforms the current running program into a different running program
- it is as if the current program never ran: a successful call to `exec` never returns

## 4. Why? Motivating The API
- why separating `fork` from `exec`?
  - essential in building a UNIX shell
  - it lets the shell run code after the call to `fork` but before the call to `exec`
  - this code can alter the environment of the program to be run by `exec`

- how does a shell work?
1. shows a prompt and waits for commands
2. figures out where in the file system the executable resides
3. calls `fork` to create a new child process
4. calls some variant of `exec` to run the command
5. calls `wait` to wait for the command to complete
6. when the child completes, the shell returns form `wait` and prints out a prompt again

- example: output redirection
  - before calling `exec`, the shell closes stdout and opens a new file to which the output
  will be directed

- UNIX pipes via `pipe` syscall
  - the output of one process is seamlessly used as input to the next
  - long chains of commands can be strung together

## 5. Process Control and Users
- how do we control processes?: `kill` syscall and **signals**
  - the signal subsystem provides a infrastructure to deliver externel events to processes
    - receiving and processing signals within individual processes
    - sending signals to individual processes and entire process groups
  - `signal` syscall to catch various signals

- **user** concept: who can send a signal to a process?
  - users generally can only control their own processes
  - it is the job of the OS to parcel out resources to each user

## 6. Useful Tools
- skim through this part

## HW(simulation)
2. as the percentage increases, the tree gets more complicated: since more branches are generated by `fork` and not got rid of by `exit`

4. 
  - if `-R` flag is not specified, those orphan processes get adopted by the initial process `a`, and all the orphan processes are considered as equal: the children of those orphan processes also become orphans
  
  - setting the `-R` flag makes those processes become children of the nearest parent process, and the subtree structure of those orphans is maintained

6. there are some cases that we can't tell whether such cases ever have happend when only the structure of the final tree is given
- leaf process exited
- parent process exited(so the current parents may not be REAL parents of their children)

## HW(code)
- see `/code/hw.c`

1. each process has its independent `x` values; sharing the initial value, but changes the value in their own ways

2. 
  - the both can access to the same output file
  - the order of each process' writing could change everytime we run the code
  - however, the characters are not mingled with the other: perhaps something to do with file system's writing syscall

3. we resort to `sleep` system call

4. each has its own purpose, but in general they are provided as a wrapper of `exec` for convenience of users

5. 
- parent: gets the terminated child's pid 
- child: gets `-1`

6. `waitpid` is for specifying one certain child to be awaited

7. nothing happens
