# Mechanism: Address Translation
- virtualization of memory
  - virtualization of the CPU: *efficienct* virtualization + maintaing *control* over HW
  - the same for virtualizing memory
    - efficiency: HW support(register, TLB, pagetable, etc.)  
    - control: the OS ensures that no application is allowed to access any memory but its own => need HW here as well
    - *flexibility*: for program to be able to use their address space in whatever way they would like

- general strategy: **(HW-based) address translation**
  - the HW transforms each memory access, changing the virtual address provided by the instruction to a physical address, where the desired information is actually located
  - but the OS must get involved at key points to set up the HW so that the correct tarnslations take place
  - **memory management** by the OS: keeping track of which locations are free and which are in use, and judiciously intervening to maintain control over how memory is used

- goal: create a beautiful illusion
  - the program has its own private memory, where its own code and data reside

## 1. Assumptions
- skim through this section

## 2. An Example
- skim through this section

## 3. Dynamic(HW based) Relocation
- **base and bounds**, or **dynamic relocation** idea
  - we have two HW registers within each CPU: **base** and **bounds** register
  - placing the address space in physical memory, while ensuring that the process can only access its own address space

- when a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value
- when any memory reference is generated by the process, it is **translated** by the processor
  - to a virtual address, the HW adds the contents of the base register to return a corresponding physical address(**address translation**)
  - the bounds register is for checking whether translated addresses are within the allowed memory region(protection)
  
- **dynamic relocation**: this relocation of address happens at runtime, and because we can move address spaces even after the process has started running
- **memory management unit(MMU)**: the part of the processor that helps with address translation

### Example Translations
- skim through this part

## 4. HW Support: A Summary
- additional notes
  - the HW should provide special instructions to modify the base and bound registers, allowing the OS to change them when different processes run(so of course, the instructions are **privileged**)
  - the CPU must be able to generate exceptions when user tries to access memory illegally, or to execute some privileged instructions like changing the base register's value

## 5. OS Issues
- what does the OS need to do when it gets involved in an address translation process?
1. when a process is created, the OS finds space for its address space in memory
2. when a process is terminated, the OS reclaims all of its memory for use in other processes or the OS
3. the OS must perform a few additional steps when a context switch occurs
  - saving and restoring the base, bounds registers as well
4. the OS must provide exception handlers, installed at boot time

## 6. Summary
- internal fragmentation issue: wasted free spaces due to fixed memory slot sizes
- **segmentation**: a generalization of base and bounds

## HW
2. `930`
3. decimal `15900`
